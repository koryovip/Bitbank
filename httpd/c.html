<!DOCTYPE html>
<meta charset="utf-8">
<style>
body {padding: 0; margin: 0;}
#chart {
	border: 0;
	padding: 0;
	margin: 0;
	background-color: #222;
}
</style>
<body>
<div style="position: relative; margin: 1px; padding: 0;">
    <canvas id="layer" width="1800" height="800" style="position: absolute; left: 0; top: 0; padding: 0; margin: 0; z-index: 1;"></canvas>
    <canvas id="chart" width="1800" height="800" style="position: absolute; left: 0; top: 0; padding: 0; margin: 0; z-index: 0;"></canvas>
</div>
<script src="./js/pubnub.4.20.2.min.js"></script>
<script>
function publish() {
    pubnub = new PubNub({
        //publishKey : 'demo',
        subscribeKey : 'sub-c-e12e9174-dd60-11e6-806b-02ee2ddab7fe'
    })
    function publishSampleMessage() {
        console.log("Since we're publishing on subscribe connectEvent, we're sure we'll receive the following publish.");
        var publishConfig = {
            channel : "hello_world",
            message : "Hello from PubNub Docs!"
        }
        pubnub.publish(publishConfig, function(status, response) {
            console.log(status, response);
        })
    }
    pubnub.addListener({
        status: function(statusEvent) {
            if (statusEvent.category === "PNConnectedCategory") {
                publishSampleMessage();
            }
        },
        message: function(message) {
            // console.log("New Message!!", message);
            if (message.message.data.candlestick) {
            	var aaa = message.message.data.candlestick;
                var index = -1;
            	for (var ii = 0; ii < aaa.length; ii++) {
            		if (aaa[ii].type === '1min') {
            			index = ii;
            			break;
            		}
            	}
            	if (index === -1) {
            		console.log('error');
            		return;
            	}
            	console.log(aaa[index].ohlcv);
            }
        },
        presence: function(presenceEvent) {
            // handle presence
        }
    })      
    console.log("Subscribing..");
    pubnub.subscribe({
        channels: ['candlestick_xrp_jpy'] 
    });
};
//publish();
// [始値, 高値, 安値, 終値]
async function getData() {
    // var d = await (await fetch('https://public.bitbank.cc/xrp_jpy/candlestick/15min/20180322')).text();
    const res = await fetch('https://public.bitbank.cc/xrp_jpy/candlestick/1min/20180327');
    if (res.status != 200) {
        throw new Error('リソースを読み込めませんでした');
    }
    return await res.json().catch(() => {
        throw new Error('JSONの形式が正しくありません');
    });
}
var pairConfig = { /* scale : 100 */ };
var config = {
    candlestick : {width : 5}
};
getData().then(result => {
    // console.log(result.data.candlestick[0].ohlcv);
    var data = result.data.candlestick[0].ohlcv;
    data = data.slice(-200);
    // console.log(data);
	var canvas = document.getElementById("chart");
	var context = canvas.getContext("2d");
	context.font = "11px Meiryo";
	var maxReal = 70;
	var minReal = 64;
	var range = maxReal - minReal;
	var chartHeight = 800; // chart height
	var step = range / chartHeight;
	console.log('step:'+step);
	// var max = maxReal * pairConfig.scale;
	{
		// x軸を描く
		var count = 20;
		for (var ii = 0; ii <= count; ii++) {
			var y = ii*(chartHeight/count);
			/*context.strokeStyle = "rgb(100,100,100)";
			context.beginPath();
			context.lineWidth = 0.1;
			context.setLineDash([2, 2]);
			context.moveTo(0, y);
			context.lineTo(1400, y);
			context.stroke();*/
			context.fillStyle = "rgb(80,80,80)";
		    context.fillRect(0, y, 1400, 0.5); // x, y, width, height // grid line
		    context.fillStyle = "rgb(255,255,255)";
	        context.textBaseline = "middle";
		    context.fillText((maxReal-y*step).toFixed(3), 1300, y); // fillText(text, x, y [, maxWidth])
		}
	}
	//var VArray = [];
	var maxScreen = {index: 0, value:0};
	var minScreen = {index: 0, value:9999999999999};
	var nowScreen = {index: 0, value:0};
	for (var ii = 0; ii < data.length; ii++) {
		var open = data[ii][0], high = data[ii][1], low = data[ii][2], close = data[ii][3];
		if (high > maxScreen.value) {
			maxScreen.index = ii;
            maxScreen.value = high;
        }
		if (low < minScreen.value) {
			minScreen.index = ii;
			minScreen.value = low;
        }
		if (open > close) {
			context.fillStyle = "rgb(255,0,0)";
		} else {
			context.fillStyle = "rgb(0,255,0)";
		}
		{
			var height = Math.abs(open - close) / step;
		    nowScreen.value = open > close ? open : close;
			var y = (maxReal - nowScreen.value) / step;
			//console.log(height+","+new Date(data[ii][5]));
			//console.log(y);
		    context.fillRect((config.candlestick.width+2)*ii+1, y, config.candlestick.width, height<1?1:height); // x, y, width, height
		}
		{
			// ひげ
	        var height = Math.abs(high - low) / step;
	        var y = (maxReal - (high > low ? high : low)) / step;
	        //console.log(height+","+new Date(data[ii][5]));
	        // console.log(y);
	        var x = (config.candlestick.width+2)*ii+1+(Math.floor(config.candlestick.width/2));
	        // console.log(x);
	        context.fillRect(x, y, 0.8, height<1?1:height); // x, y, width, height
		}
	}
	console.log(nowScreen.value);
	context.fillStyle = "rgb(255,255,0)";
	context.fillRect(0, (maxReal-maxScreen.value)/step, 1400, 0.5);
	context.fillRect(0, (maxReal-minScreen.value)/step, 1400, 0.5);
	context.fillStyle = "rgb(0,255,255)";
	context.fillRect(0, (maxReal-nowScreen.value)/step, 1400, 0.5);
	/**
	 * フォーマット関数
	 */
	var $format = function(fmt, a) {
	    var rep_fn = undefined;
	    if (typeof a == "object") {
	        rep_fn = function(m, k) { return a[ k ]; }
	    } else {
	        var args = arguments;
	        rep_fn = function(m, k) { return args[ parseInt(k)+1 ]; }
	    }
	    return fmt.replace( /\{(\w+)\}/g, rep_fn);
	};
	var padding = function(n, d, p) {
	    p = p || '0';
	    return (p.repeat(d) + n).slice(-d);
	};
	var formatDt = function(date) {
		return $format('{0}/{1} {2}:{3}', padding(date.getMonth()+1,2), padding(date.getDate(),2), padding(date.getHours(),2), padding(date.getMinutes(),2));
	};
	/*
	 * マウスカーソルの動きに追従する
	 */
	function m_move(canvas, line1, line2) {
	    //var cs = document.getElementById('e_m_move');
	    var context = canvas.getContext('2d');
	    var w = canvas.width;
	    var h = canvas.height;
	    var offsetX = canvas.getBoundingClientRect().left;
	    var offsetY = canvas.getBoundingClientRect().top;
	    function onMouseMove(e) {
	    	// console.log(e);
		    var x = e.clientX - offsetX;
		    var y = e.clientY - offsetY;
		    context.fillStyle = "rgb(255,0,0)";
	    	context.clearRect(0, 0, w, h);
	    	context.fillRect(0, y, 1400, 0.5); // H line
	    	
	        var xx = (config.candlestick.width+2) * Math.floor(x / (config.candlestick.width+2))+(Math.floor(config.candlestick.width/2))+1;
	    	//console.log(xx/11);
	    	context.fillRect(xx, 0, 0.5, 800);  // V line
	    	// price
	    	{
		    	var priceText = (maxReal-y*step).toFixed(3);
		    	// measureText() を使って、文字列にアンダーラインや背景ボックスをつける
		    	var txw1 = context.measureText(priceText);
		    	context.fillStyle = "rgb(125,125,125)";
		    	context.fillRect(1300, y-6, txw1.width, 11); // 11=font size
		    	context.fillStyle = "rgb(255,255,255)";
		    	context.textBaseline = "middle";
		    	context.fillText(priceText, 1300, y); // fillText(text, x, y [, maxWidth])
	    	}
	    	// date
	    	{
	    	   var idx = Math.floor(xx/11);
	    	   context.textBaseline = "bottom";
	    	   context.fillText(formatDt(new Date(data[idx][5])), xx, chartHeight); // fillText(text, x, y [, maxWidth])
	    	}
	    	// label
	        {
	            var label = $format('Open:{0}  High:{1}  Low:{2}  Close:{3}', data[idx][0], data[idx][1], data[idx][2], data[idx][3]);
	            context.textBaseline = "top";
	            context.fillText(label, 0, 0);
	        }
	    }
	
	    canvas.addEventListener('mousemove', onMouseMove, false);
	}
	var line1 = document.getElementById('line1');
	var line2 = document.getElementById('line2');
	m_move(document.getElementById("layer"), line1, line2);
});
</script>
</body>